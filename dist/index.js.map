{"version":3,"file":"index.js","mappings":";AAAA;AACA;AACA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;ACAA;AACA;;;;;;;;;;;ACDA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5TA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://pr-conventional-commit-check/webpack/bootstrap","../webpack://pr-conventional-commit-check/webpack/runtime/define property getters","../webpack://pr-conventional-commit-check/webpack/runtime/hasOwnProperty shorthand","../webpack://pr-conventional-commit-check/webpack/runtime/compat","../webpack://pr-conventional-commit-check/external node-commonjs \"node:module\"","../webpack://pr-conventional-commit-check/./node_modules/conventional-commits-parser/dist/regex.js","../webpack://pr-conventional-commit-check/./node_modules/conventional-commits-parser/dist/utils.js","../webpack://pr-conventional-commit-check/./node_modules/conventional-commits-parser/dist/options.js","../webpack://pr-conventional-commit-check/./node_modules/conventional-commits-parser/dist/CommitParser.js","../webpack://pr-conventional-commit-check/external node-commonjs \"stream\"","../webpack://pr-conventional-commit-check/./node_modules/conventional-commits-parser/dist/stream.js","../webpack://pr-conventional-commit-check/./node_modules/conventional-commits-parser/dist/index.js","../webpack://pr-conventional-commit-check/./index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:module\");","const nomatchRegex = /(?!.*)/;\nfunction join(parts, joiner) {\n    return parts\n        .map(val => val.trim())\n        .filter(Boolean)\n        .join(joiner);\n}\nfunction getNotesRegex(noteKeywords, notesPattern) {\n    if (!noteKeywords) {\n        return nomatchRegex;\n    }\n    const noteKeywordsSelection = join(noteKeywords, '|');\n    if (!notesPattern) {\n        return new RegExp(`^[\\\\s|*]*(${noteKeywordsSelection})[:\\\\s]+(.*)`, 'i');\n    }\n    return notesPattern(noteKeywordsSelection);\n}\nfunction getReferencePartsRegex(issuePrefixes, issuePrefixesCaseSensitive) {\n    if (!issuePrefixes) {\n        return nomatchRegex;\n    }\n    const flags = issuePrefixesCaseSensitive ? 'g' : 'gi';\n    return new RegExp(`(?:.*?)??\\\\s*([\\\\w-\\\\.\\\\/]*?)??(${join(issuePrefixes, '|')})([\\\\w-]*\\\\d+)`, flags);\n}\nfunction getReferencesRegex(referenceActions) {\n    if (!referenceActions) {\n        // matches everything\n        return /()(.+)/gi;\n    }\n    const joinedKeywords = join(referenceActions, '|');\n    return new RegExp(`(${joinedKeywords})(?:\\\\s+(.*?))(?=(?:${joinedKeywords})|$)`, 'gi');\n}\n/**\n * Make the regexes used to parse a commit.\n * @param options\n * @returns Regexes.\n */\nexport function getParserRegexes(options = {}) {\n    const notes = getNotesRegex(options.noteKeywords, options.notesPattern);\n    const referenceParts = getReferencePartsRegex(options.issuePrefixes, options.issuePrefixesCaseSensitive);\n    const references = getReferencesRegex(options.referenceActions);\n    return {\n        notes,\n        referenceParts,\n        references,\n        mentions: /@([\\w-]+)/g\n    };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVnZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvcmVnZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBS0EsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFBO0FBRTdCLFNBQVMsSUFBSSxDQUFDLEtBQWUsRUFBRSxNQUFjO0lBQzNDLE9BQU8sS0FBSztTQUNULEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUN0QixNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQ2pCLENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FDcEIsWUFBa0MsRUFDbEMsWUFBb0Q7SUFFcEQsSUFBSSxDQUFDLFlBQVksRUFBRTtRQUNqQixPQUFPLFlBQVksQ0FBQTtLQUNwQjtJQUVELE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLENBQUMsQ0FBQTtJQUVyRCxJQUFJLENBQUMsWUFBWSxFQUFFO1FBQ2pCLE9BQU8sSUFBSSxNQUFNLENBQUMsYUFBYSxxQkFBcUIsY0FBYyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0tBQ3pFO0lBRUQsT0FBTyxZQUFZLENBQUMscUJBQXFCLENBQUMsQ0FBQTtBQUM1QyxDQUFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FDN0IsYUFBbUMsRUFDbkMsMEJBQStDO0lBRS9DLElBQUksQ0FBQyxhQUFhLEVBQUU7UUFDbEIsT0FBTyxZQUFZLENBQUE7S0FDcEI7SUFFRCxNQUFNLEtBQUssR0FBRywwQkFBMEIsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUE7SUFFckQsT0FBTyxJQUFJLE1BQU0sQ0FBQyxtQ0FBbUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLENBQUE7QUFDdkcsQ0FBQztBQUVELFNBQVMsa0JBQWtCLENBQ3pCLGdCQUFzQztJQUV0QyxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7UUFDckIscUJBQXFCO1FBQ3JCLE9BQU8sVUFBVSxDQUFBO0tBQ2xCO0lBRUQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEdBQUcsQ0FBQyxDQUFBO0lBRWxELE9BQU8sSUFBSSxNQUFNLENBQUMsSUFBSSxjQUFjLHVCQUF1QixjQUFjLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUN4RixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FDOUIsVUFBc0ksRUFBRTtJQUV4SSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUE7SUFDdkUsTUFBTSxjQUFjLEdBQUcsc0JBQXNCLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQTtJQUN4RyxNQUFNLFVBQVUsR0FBRyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtJQUUvRCxPQUFPO1FBQ0wsS0FBSztRQUNMLGNBQWM7UUFDZCxVQUFVO1FBQ1YsUUFBUSxFQUFFLFlBQVk7S0FDdkIsQ0FBQTtBQUNILENBQUMifQ==","const SCISSOR = '# ------------------------ >8 ------------------------';\n/**\n * Remove leading and trailing newlines.\n * @param input\n * @returns String without leading and trailing newlines.\n */\nexport function trimNewLines(input) {\n    // To escape ReDos we should escape String#replace with regex.\n    const matches = input.match(/[^\\r\\n]/);\n    if (typeof matches?.index !== 'number') {\n        return '';\n    }\n    const firstIndex = matches.index;\n    let lastIndex = input.length - 1;\n    while (input[lastIndex] === '\\r' || input[lastIndex] === '\\n') {\n        lastIndex--;\n    }\n    return input.substring(firstIndex, lastIndex + 1);\n}\n/**\n * Append a newline to a string.\n * @param src\n * @param line\n * @returns String with appended newline.\n */\nexport function appendLine(src, line) {\n    return src ? `${src}\\n${line || ''}` : line || '';\n}\n/**\n * Creates a function that filters out comments lines.\n * @param char\n * @returns Comment filter function.\n */\nexport function getCommentFilter(char) {\n    return char\n        ? (line) => !line.startsWith(char)\n        : () => true;\n}\n/**\n * Select lines before the scissor.\n * @param lines\n * @returns Lines before the scissor.\n */\nexport function truncateToScissor(lines) {\n    const scissorIndex = lines.indexOf(SCISSOR);\n    if (scissorIndex === -1) {\n        return lines;\n    }\n    return lines.slice(0, scissorIndex);\n}\n/**\n * Filter out GPG sign lines.\n * @param line\n * @returns True if the line is not a GPG sign line.\n */\nexport function gpgFilter(line) {\n    return !line.match(/^\\s*gpg:/);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxPQUFPLEdBQUcsd0RBQXdELENBQUE7QUFFeEU7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxZQUFZLENBQUMsS0FBYTtJQUN4Qyw4REFBOEQ7SUFFOUQsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQTtJQUV0QyxJQUFJLE9BQU8sT0FBTyxFQUFFLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDdEMsT0FBTyxFQUFFLENBQUE7S0FDVjtJQUVELE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUE7SUFDaEMsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUE7SUFFaEMsT0FBTyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssSUFBSSxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDN0QsU0FBUyxFQUFFLENBQUE7S0FDWjtJQUVELE9BQU8sS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBQ25ELENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxVQUFVLENBQUMsR0FBa0IsRUFBRSxJQUF3QjtJQUNyRSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEtBQUssSUFBSSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFBO0FBQ25ELENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGdCQUFnQixDQUFDLElBQXdCO0lBQ3ZELE9BQU8sSUFBSTtRQUNULENBQUMsQ0FBQyxDQUFDLElBQVksRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztRQUMxQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFBO0FBQ2hCLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGlCQUFpQixDQUFDLEtBQWU7SUFDL0MsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUUzQyxJQUFJLFlBQVksS0FBSyxDQUFDLENBQUMsRUFBRTtRQUN2QixPQUFPLEtBQUssQ0FBQTtLQUNiO0lBRUQsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQTtBQUNyQyxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxTQUFTLENBQUMsSUFBWTtJQUNwQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQTtBQUNoQyxDQUFDIn0=","export const defaultOptions = {\n    noteKeywords: ['BREAKING CHANGE', 'BREAKING-CHANGE'],\n    issuePrefixes: ['#'],\n    referenceActions: [\n        'close',\n        'closes',\n        'closed',\n        'fix',\n        'fixes',\n        'fixed',\n        'resolve',\n        'resolves',\n        'resolved'\n    ],\n    headerPattern: /^(\\w*)(?:\\(([\\w$.\\-*/ ]*)\\))?: (.*)$/,\n    headerCorrespondence: [\n        'type',\n        'scope',\n        'subject'\n    ],\n    revertPattern: /^Revert\\s\"([\\s\\S]*)\"\\s*This reverts commit (\\w*)\\./,\n    revertCorrespondence: ['header', 'hash'],\n    fieldPattern: /^-(.*?)-$/\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9vcHRpb25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBa0I7SUFDM0MsWUFBWSxFQUFFLENBQUMsaUJBQWlCLEVBQUUsaUJBQWlCLENBQUM7SUFDcEQsYUFBYSxFQUFFLENBQUMsR0FBRyxDQUFDO0lBQ3BCLGdCQUFnQixFQUFFO1FBQ2hCLE9BQU87UUFDUCxRQUFRO1FBQ1IsUUFBUTtRQUNSLEtBQUs7UUFDTCxPQUFPO1FBQ1AsT0FBTztRQUNQLFNBQVM7UUFDVCxVQUFVO1FBQ1YsVUFBVTtLQUNYO0lBQ0QsYUFBYSxFQUFFLHNDQUFzQztJQUNyRCxvQkFBb0IsRUFBRTtRQUNwQixNQUFNO1FBQ04sT0FBTztRQUNQLFNBQVM7S0FDVjtJQUNELGFBQWEsRUFBRSxvREFBb0Q7SUFDbkUsb0JBQW9CLEVBQUUsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDO0lBQ3hDLFlBQVksRUFBRSxXQUFXO0NBQzFCLENBQUEifQ==","import { getParserRegexes } from './regex.js';\nimport { trimNewLines, appendLine, getCommentFilter, gpgFilter, truncateToScissor } from './utils.js';\nimport { defaultOptions } from './options.js';\n/**\n * Helper to create commit object.\n * @param initialData - Initial commit data.\n * @returns Commit object with empty data.\n */\nexport function createCommitObject(initialData = {}) {\n    // @ts-expect-error: You can read properties from `Commit` without problems, but you can't assign object to this type. So here is helper for that.\n    return {\n        merge: null,\n        revert: null,\n        header: null,\n        body: null,\n        footer: null,\n        notes: [],\n        mentions: [],\n        references: [],\n        ...initialData\n    };\n}\n/**\n * Commit message parser.\n */\nexport class CommitParser {\n    options;\n    regexes;\n    lines = [];\n    lineIndex = 0;\n    commit = createCommitObject();\n    constructor(options = {}) {\n        this.options = {\n            ...defaultOptions,\n            ...options\n        };\n        this.regexes = getParserRegexes(this.options);\n    }\n    currentLine() {\n        return this.lines[this.lineIndex];\n    }\n    nextLine() {\n        return this.lines[this.lineIndex++];\n    }\n    isLineAvailable() {\n        return this.lineIndex < this.lines.length;\n    }\n    parseReference(input, action) {\n        const { regexes } = this;\n        const matches = regexes.referenceParts.exec(input);\n        if (!matches) {\n            return null;\n        }\n        let [raw, repository = null, prefix, issue] = matches;\n        let owner = null;\n        if (repository) {\n            const slashIndex = repository.indexOf('/');\n            if (slashIndex !== -1) {\n                owner = repository.slice(0, slashIndex);\n                repository = repository.slice(slashIndex + 1);\n            }\n        }\n        return {\n            raw,\n            action,\n            owner,\n            repository,\n            prefix,\n            issue\n        };\n    }\n    parseReferences(input) {\n        const { regexes } = this;\n        const regex = input.match(regexes.references)\n            ? regexes.references\n            : /()(.+)/gi;\n        const references = [];\n        let matches;\n        let action;\n        let sentence;\n        let reference;\n        while (true) {\n            matches = regex.exec(input);\n            if (!matches) {\n                break;\n            }\n            action = matches[1] || null;\n            sentence = matches[2] || '';\n            while (true) {\n                reference = this.parseReference(sentence, action);\n                if (!reference) {\n                    break;\n                }\n                references.push(reference);\n            }\n        }\n        return references;\n    }\n    skipEmptyLines() {\n        let line = this.currentLine();\n        while (line !== undefined && !line.trim()) {\n            this.nextLine();\n            line = this.currentLine();\n        }\n    }\n    parseMerge() {\n        const { commit, options } = this;\n        const correspondence = options.mergeCorrespondence || [];\n        const merge = this.currentLine();\n        const matches = merge && options.mergePattern\n            ? merge.match(options.mergePattern)\n            : null;\n        if (matches) {\n            this.nextLine();\n            commit.merge = matches[0] || null;\n            correspondence.forEach((key, index) => {\n                commit[key] = matches[index + 1] || null;\n            });\n            return true;\n        }\n        return false;\n    }\n    parseHeader(isMergeCommit) {\n        if (isMergeCommit) {\n            this.skipEmptyLines();\n        }\n        const { commit, options } = this;\n        const correspondence = options.headerCorrespondence || [];\n        const header = this.nextLine();\n        let matches = null;\n        if (header) {\n            if (options.breakingHeaderPattern) {\n                matches = header.match(options.breakingHeaderPattern);\n            }\n            if (!matches && options.headerPattern) {\n                matches = header.match(options.headerPattern);\n            }\n        }\n        if (header) {\n            commit.header = header;\n        }\n        if (matches) {\n            correspondence.forEach((key, index) => {\n                commit[key] = matches[index + 1] || null;\n            });\n        }\n    }\n    parseMeta() {\n        const { options, commit } = this;\n        if (!options.fieldPattern || !this.isLineAvailable()) {\n            return false;\n        }\n        let matches;\n        let field = null;\n        let parsed = false;\n        while (this.isLineAvailable()) {\n            matches = this.currentLine().match(options.fieldPattern);\n            if (matches) {\n                field = matches[1] || null;\n                this.nextLine();\n                continue;\n            }\n            if (field) {\n                parsed = true;\n                commit[field] = appendLine(commit[field], this.currentLine());\n                this.nextLine();\n            }\n            else {\n                break;\n            }\n        }\n        return parsed;\n    }\n    parseNotes() {\n        const { regexes, commit } = this;\n        if (!this.isLineAvailable()) {\n            return false;\n        }\n        const matches = this.currentLine().match(regexes.notes);\n        let references = [];\n        if (matches) {\n            const note = {\n                title: matches[1],\n                text: matches[2]\n            };\n            commit.notes.push(note);\n            commit.footer = appendLine(commit.footer, this.currentLine());\n            this.nextLine();\n            while (this.isLineAvailable()) {\n                if (this.parseMeta()) {\n                    return true;\n                }\n                if (this.parseNotes()) {\n                    return true;\n                }\n                references = this.parseReferences(this.currentLine());\n                if (references.length) {\n                    commit.references.push(...references);\n                }\n                else {\n                    note.text = appendLine(note.text, this.currentLine());\n                }\n                commit.footer = appendLine(commit.footer, this.currentLine());\n                this.nextLine();\n                if (references.length) {\n                    break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    parseBodyAndFooter(isBody) {\n        const { commit } = this;\n        if (!this.isLineAvailable()) {\n            return isBody;\n        }\n        const references = this.parseReferences(this.currentLine());\n        const isStillBody = !references.length && isBody;\n        if (isStillBody) {\n            commit.body = appendLine(commit.body, this.currentLine());\n        }\n        else {\n            commit.references.push(...references);\n            commit.footer = appendLine(commit.footer, this.currentLine());\n        }\n        this.nextLine();\n        return isStillBody;\n    }\n    parseBreakingHeader() {\n        const { commit, options } = this;\n        if (!options.breakingHeaderPattern || commit.notes.length || !commit.header) {\n            return;\n        }\n        const matches = commit.header.match(options.breakingHeaderPattern);\n        if (matches) {\n            commit.notes.push({\n                title: 'BREAKING CHANGE',\n                text: matches[3]\n            });\n        }\n    }\n    parseMentions(input) {\n        const { commit, regexes } = this;\n        let matches;\n        for (;;) {\n            matches = regexes.mentions.exec(input);\n            if (!matches) {\n                break;\n            }\n            commit.mentions.push(matches[1]);\n        }\n    }\n    parseRevert(input) {\n        const { commit, options } = this;\n        const correspondence = options.revertCorrespondence || [];\n        const matches = options.revertPattern\n            ? input.match(options.revertPattern)\n            : null;\n        if (matches) {\n            commit.revert = correspondence.reduce((meta, key, index) => {\n                meta[key] = matches[index + 1] || null;\n                return meta;\n            }, {});\n        }\n    }\n    cleanupCommit() {\n        const { commit } = this;\n        if (commit.body) {\n            commit.body = trimNewLines(commit.body);\n        }\n        if (commit.footer) {\n            commit.footer = trimNewLines(commit.footer);\n        }\n        commit.notes.forEach((note) => {\n            note.text = trimNewLines(note.text);\n        });\n    }\n    /**\n     * Parse commit message string into an object.\n     * @param input - Commit message string.\n     * @returns Commit object.\n     */\n    parse(input) {\n        if (!input.trim()) {\n            throw new TypeError('Expected a raw commit');\n        }\n        const commentFilter = getCommentFilter(this.options.commentChar);\n        const rawLines = trimNewLines(input).split(/\\r?\\n/);\n        const lines = truncateToScissor(rawLines).filter(line => commentFilter(line) && gpgFilter(line));\n        const commit = createCommitObject();\n        this.lines = lines;\n        this.lineIndex = 0;\n        this.commit = commit;\n        const isMergeCommit = this.parseMerge();\n        this.parseHeader(isMergeCommit);\n        if (commit.header) {\n            commit.references = this.parseReferences(commit.header);\n        }\n        let isBody = true;\n        while (this.isLineAvailable()) {\n            this.parseMeta();\n            if (this.parseNotes()) {\n                isBody = false;\n            }\n            if (!this.parseBodyAndFooter(isBody)) {\n                isBody = false;\n            }\n        }\n        this.parseBreakingHeader();\n        this.parseMentions(input);\n        this.parseRevert(input);\n        this.cleanupCommit();\n        return commit;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tbWl0UGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0NvbW1pdFBhcnNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFRQSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxZQUFZLENBQUE7QUFDN0MsT0FBTyxFQUNMLFlBQVksRUFDWixVQUFVLEVBQ1YsZ0JBQWdCLEVBQ2hCLFNBQVMsRUFDVCxpQkFBaUIsRUFDbEIsTUFBTSxZQUFZLENBQUE7QUFDbkIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGNBQWMsQ0FBQTtBQUU3Qzs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUFDLGNBQStCLEVBQUU7SUFDbEUsa0pBQWtKO0lBQ2xKLE9BQU87UUFDTCxLQUFLLEVBQUUsSUFBSTtRQUNYLE1BQU0sRUFBRSxJQUFJO1FBQ1osTUFBTSxFQUFFLElBQUk7UUFDWixJQUFJLEVBQUUsSUFBSTtRQUNWLE1BQU0sRUFBRSxJQUFJO1FBQ1osS0FBSyxFQUFFLEVBQUU7UUFDVCxRQUFRLEVBQUUsRUFBRTtRQUNaLFVBQVUsRUFBRSxFQUFFO1FBQ2QsR0FBRyxXQUFXO0tBQ2YsQ0FBQTtBQUNILENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBQ04sT0FBTyxDQUFlO0lBQ3RCLE9BQU8sQ0FBZTtJQUMvQixLQUFLLEdBQWEsRUFBRSxDQUFBO0lBQ3BCLFNBQVMsR0FBRyxDQUFDLENBQUE7SUFDYixNQUFNLEdBQUcsa0JBQWtCLEVBQUUsQ0FBQTtJQUVyQyxZQUFZLFVBQXlCLEVBQUU7UUFDckMsSUFBSSxDQUFDLE9BQU8sR0FBRztZQUNiLEdBQUcsY0FBYztZQUNqQixHQUFHLE9BQU87U0FDWCxDQUFBO1FBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUE7SUFDL0MsQ0FBQztJQUVPLFdBQVc7UUFDakIsT0FBTyxJQUFJLENBQUMsS0FBSyxD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","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"stream\");","import { Transform } from 'stream';\nimport { CommitParser } from './CommitParser.js';\n/**\n * Create async generator function to parse async iterable of raw commits.\n * @param options - CommitParser options.\n * @returns Async generator function to parse async iterable of raw commits.\n */\nexport function parseCommits(options = {}) {\n    const warnOption = options.warn;\n    const warn = warnOption === true\n        ? (err) => {\n            throw err;\n        }\n        : warnOption\n            ? (err) => warnOption(err.toString())\n            : () => { };\n    return async function* parse(rawCommits) {\n        const parser = new CommitParser(options);\n        let rawCommit;\n        for await (rawCommit of rawCommits) {\n            try {\n                yield parser.parse(rawCommit.toString());\n            }\n            catch (err) {\n                warn(err);\n            }\n        }\n    };\n}\n/**\n * Create stream to parse commits.\n * @param options - CommitParser options.\n * @returns Stream of parsed commits.\n */\nexport function parseCommitsStream(options = {}) {\n    return Transform.from(parseCommits(options));\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyZWFtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3N0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sUUFBUSxDQUFBO0FBRWxDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQTtBQUVoRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FDMUIsVUFBK0IsRUFBRTtJQUVqQyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFBO0lBQy9CLE1BQU0sSUFBSSxHQUFHLFVBQVUsS0FBSyxJQUFJO1FBQzlCLENBQUMsQ0FBQyxDQUFDLEdBQVUsRUFBRSxFQUFFO1lBQ2YsTUFBTSxHQUFHLENBQUE7UUFDWCxDQUFDO1FBQ0QsQ0FBQyxDQUFDLFVBQVU7WUFDVixDQUFDLENBQUMsQ0FBQyxHQUFVLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDNUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFjLENBQUMsQ0FBQTtJQUUxQixPQUFPLEtBQUssU0FBUyxDQUFDLENBQUMsS0FBSyxDQUMxQixVQUFzRTtRQUV0RSxNQUFNLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUN4QyxJQUFJLFNBQTBCLENBQUE7UUFFOUIsSUFBSSxLQUFLLEVBQUUsU0FBUyxJQUFJLFVBQVUsRUFBRTtZQUNsQyxJQUFJO2dCQUNGLE1BQU0sTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQTthQUN6QztZQUFDLE9BQU8sR0FBRyxFQUFFO2dCQUNaLElBQUksQ0FBQyxHQUFZLENBQUMsQ0FBQTthQUNuQjtTQUNGO0lBQ0gsQ0FBQyxDQUFBO0FBQ0gsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBQUMsVUFBK0IsRUFBRTtJQUNsRSxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUE7QUFDOUMsQ0FBQyJ9","export * from './types.js';\nexport * from './CommitParser.js';\nexport * from './stream.js';\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxZQUFZLENBQUE7QUFDMUIsY0FBYyxtQkFBbUIsQ0FBQTtBQUNqQyxjQUFjLGFBQWEsQ0FBQSJ9","import { createRequire } from 'node:module';\r\nconst require = createRequire(import.meta.url);\r\n\r\nconst { getInput, setFailed } = require('@actions/core');\r\nconst { getOctokit, context } = require('@actions/github');\r\nimport { CommitParser } from 'conventional-commits-parser'\r\n\r\nconst parser = new CommitParser();\r\n\r\n/**\r\n * Main function to run the whole process.\r\n */\r\nasync function run() {\r\n    const commitDetail = await checkConventionalCommits();\r\n    await checkTicketNumber(commitDetail);\r\n    const pr = context.payload.pull_request;\r\n    await applyLabel(pr, commitDetail);\r\n}\r\n\r\n\r\n/**\r\n * Check the conventional commits of the task.\r\n * Parse the title of the pull request and validate against the task type list.\r\n * @returns {Promise<Object>} An object with details of the commit: type, scope and whether it's a breaking change.\r\n */\r\nasync function checkConventionalCommits() {\r\n    let taskTypesInput = getInput('task_types');\r\n    if (!taskTypesInput) {\r\n        setFailed('Missing required input: task_types');\r\n        return;\r\n    }\r\n    let taskTypeList;\r\n    try {\r\n        taskTypeList = JSON.parse(taskTypesInput);\r\n    } catch (err) {\r\n        setFailed('Invalid task_types input. Expecting a JSON array.');\r\n        return;\r\n    }\r\n\r\n    const pr = context.payload.pull_request;\r\n    const titleAst = parser.parse(pr.title);\r\n    const cc = {\r\n        type: titleAst.type ? titleAst.type : '',\r\n        scope: titleAst.scope ? titleAst.scope : '',\r\n        breaking: titleAst.notes && titleAst.notes.some(note => note.title === 'BREAKING CHANGE'),\r\n    };\r\n    if (!cc.type || !taskTypeList.includes(cc.type)) {\r\n        setFailed(`Invalid or missing task type: '${cc.type}'. Must be one of: ${taskTypeList.join(', ')}`);\r\n        return;\r\n    }\r\n    return cc;\r\n}\r\n\r\n/**\r\n * Check the ticket number based on the PR title and a provided regex.\r\n */\r\nasync function checkTicketNumber() {\r\n    const ticketKeyRegex = getInput('ticket_key_regex');\r\n    if (ticketKeyRegex) {\r\n        const pr = context.payload.pull_request;\r\n        const taskNumberMatch = pr.title.match(new RegExp(ticketKeyRegex));\r\n        const taskNumber = taskNumberMatch ? taskNumberMatch[0] : '';\r\n        if (!taskNumber) {\r\n            setFailed(`Invalid or missing task number: '${taskNumber}'. Must match: ${ticketKeyRegex}`);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Apply labels to the pull request based on the details of the commit and any custom labels provided.\r\n * @param {Object} pr The pull request object.\r\n * @param {Object} commitDetail The object with details of the commit.\r\n */\r\nasync function applyLabel(pr, commitDetail) {\r\n    const addLabel = getInput('add_label');\r\n    if (addLabel !== undefined && addLabel.toLowerCase() === 'false') {\r\n        return;\r\n    }\r\n    const customLabelsInput = getInput('custom_labels');\r\n    let customLabels = {};\r\n    if (customLabelsInput) {\r\n        try {\r\n            customLabels = JSON.parse(customLabelsInput);\r\n            // Validate that customLabels is an object and all its keys and values are strings\r\n            if (typeof customLabels !== 'object' || Array.isArray(customLabels) || Object.entries(customLabels).some(([k, v]) => typeof k !== 'string' || typeof v !== 'string')) {\r\n                setFailed('Invalid custom_labels input. Expecting a JSON object with string keys and values.');\r\n                return;\r\n            }\r\n        } catch (err) {\r\n            setFailed('Invalid custom_labels input. Unable to parse JSON.');\r\n            return;\r\n        }\r\n    }\r\n    await updateLabels(pr, commitDetail, customLabels);\r\n}\r\n\r\n/**\r\n * Update labels on the pull request.\r\n */\r\nasync function updateLabels(pr, cc, customLabels) {\r\n    const token = getInput('token');\r\n    const octokit = getOctokit(token);\r\n    const currentLabelsResult = await octokit.rest.issues.listLabelsOnIssue({\r\n        owner: context.repo.owner,\r\n        repo: context.repo.repo,\r\n        issue_number: pr.number\r\n    });\r\n    const currentLabels = currentLabelsResult.data.map(label => label.name);\r\n    let taskTypesInput = getInput('task_types');\r\n    let taskTypeList = JSON.parse(taskTypesInput);\r\n    const managedLabels = taskTypeList.concat(['breaking change']);\r\n    // Include customLabels keys in managedLabels, if any\r\n    Object.values(customLabels).forEach(label => {\r\n        if (!managedLabels.includes(label)) {\r\n            managedLabels.push(label);\r\n        }\r\n    });\r\n    let newLabels = [customLabels[cc.type] ? customLabels[cc.type] : cc.type];\r\n    const breakingChangeLabel = 'breaking change';\r\n    if (cc.breaking && !newLabels.includes(breakingChangeLabel)) {\r\n        newLabels.push(breakingChangeLabel);\r\n    }\r\n    // Determine labels to remove and remove them\r\n    const labelsToRemove = currentLabels.filter(label => managedLabels.includes(label) && !newLabels.includes(label));\r\n    for (let label of labelsToRemove) {\r\n        await octokit.rest.issues.removeLabel({\r\n            owner: context.repo.owner,\r\n            repo: context.repo.repo,\r\n            issue_number: pr.number,\r\n            name: label\r\n        });\r\n    }\r\n    // Ensure new labels exist with the desired color and add them\r\n    for (let label of newLabels) {\r\n        if (!currentLabels.includes(label)) {\r\n            try {\r\n                await octokit.rest.issues.getLabel({\r\n                    owner: context.repo.owner,\r\n                    repo: context.repo.repo,\r\n                    name: label\r\n                });\r\n            } catch (err) {\r\n                // Label does not exist, create it\r\n                let color = generateColor(label);\r\n                await octokit.rest.issues.createLabel({\r\n                    owner: context.repo.owner,\r\n                    repo: context.repo.repo,\r\n                    name: label,\r\n                    color: color\r\n                });\r\n            }\r\n\r\n            // Add the label to the PR\r\n            await octokit.rest.issues.addLabels({\r\n                owner: context.repo.owner,\r\n                repo: context.repo.repo,\r\n                issue_number: pr.number,\r\n                labels: [label],\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Generates a color based on the string input.\r\n */\r\nfunction generateColor(str) {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        hash = str.charCodeAt(i) + ((hash << 5) - hash);\r\n    }\r\n\r\n    let color = '';\r\n    for (let i = 0; i < 3; i++) {\r\n        let value = (hash >> (i * 8)) & 0xFF;\r\n        color += ('00' + value.toString(16)).substr(-2);\r\n    }\r\n\r\n    return color;\r\n}\r\n\r\nrun().catch(err => setFailed(err.message));\r\n\r\nexport default {\r\n    run,\r\n    checkConventionalCommits,\r\n    checkTicketNumber,\r\n    applyLabel,\r\n    updateLabels,\r\n    generateColor\r\n};\r\n"],"names":[],"sourceRoot":""}